/*
 * Copyright (C) Balena.io - All Rights Reserved
 * Unauthorized copying of this file, via any medium is strictly prohibited.
 * Proprietary and confidential.
 */
import { SyncActionContext } from './sync-context';
import * as JellyfishTypes from '@balena/jellyfish-types';
import { Operation } from 'fast-json-patch';
import { AssertErrorConstructor } from '@balena/jellyfish-assert/build/types';
import type { JSONSchema6 } from 'json-schema';
import * as JSONPatch from 'fast-json-patch';

interface ExecuteOptions {
	attachEvents: boolean;
	timestamp: any;
	actor: string | null;
	originator?: string;
}

// The worker context is generated by the `jellyfish-worker` module.
// See https://github.com/product-os/jellyfish-worker/blob/master/lib/index.js#L198
export interface WorkerContext {
	getCardById: (
		session: string,
		id: string,
	) => Promise<JellyfishTypes.core.Contract | null>;
	getCardBySlug: (
		session: string,
		slug: string,
	) => Promise<JellyfishTypes.core.Contract | null>;
	errors: {
		WorkerNoElement: AssertErrorConstructor;
	};
	insertCard: (
		session: string,
		typeContract: JellyfishTypes.core.Contract,
		options: ExecuteOptions,
		contract: JellyfishTypes.core.Contract,
	) => Promise<JellyfishTypes.core.Contract>;
	defaults: (
		contract: Partial<JellyfishTypes.core.Contract>,
	) => JellyfishTypes.core.Contract;
	patchCard: (
		session: string,
		typeContract: JellyfishTypes.core.Contract,
		options: ExecuteOptions,
		contract: JellyfishTypes.core.Contract,
		patch: JSONPatch.Operation[],
	) => Promise<JellyfishTypes.core.Contract>;
	query: (
		session: string,
		schema: JSONSchema6,
		options: {
			limit?: number;
			sortBy?: string;
			sortDir?: string;
		},
	) => Promise<JellyfishTypes.core.Contract[]>;
}

export interface ActorInformation {
	handle: any;
	email: any;
	title: any;
	company: any;
	country: any;
	city: any;
	active: any;
}

export interface PipelineOpts {
	actor: string;
	origin: string;
	defaultUser: string;
	provider: string;
	token: any;
	context: SyncActionContext;
}

export interface SequenceItem {
	time: Date;
	actor: string;
	card:
		| (Partial<JellyfishTypes.core.Contract> &
				Pick<JellyfishTypes.core.Contract, 'slug' | 'type'>)
		| {
				id: string;
				type: string;
				patch: Operation[];
		  };
}

export interface Integration {
	initialize: () => Promise<any>;
	destroy: () => Promise<any>;
	translate: (
		contract: JellyfishTypes.core.Contract,
		options: { actor: string },
	) => Promise<SequenceItem[]>;
	mirror: (
		contract: JellyfishTypes.core.Contract,
		options: { actor: string },
	) => Promise<SequenceItem[]>;
	getFile: (file: string) => Promise<Buffer>;
}

export interface IntegrationConstructorParams {
	errors: any;
	token: any;
	defaultUser: string;
	context: {
		log: SyncActionContext['log'];
		getRemoteUsername: SyncActionContext['getRemoteUsername'];
		getLocalUsername: SyncActionContext['getLocalUsername'];
		getElementBySlug: SyncActionContext['getElementBySlug'];
		getElementById: SyncActionContext['getElementById'];
		getElementByMirrorId: SyncActionContext['getElementByMirrorId'];
		request: (
			actor: boolean,
			requestOptions: any,
		) => Promise<{ code: number; body: any }>;
		getActorId: (information: ActorInformation) => Promise<string>;
	};
}

export interface IntegrationConstructor {
	OAUTH_BASE_URL?: string;
	OAUTH_SCOPES?: string[];
	isEventValid: (
		token: any,
		rawEvent: any,
		headers: { [key: string]: string },
		loggerContext: any,
	) => boolean;
	whoami: (
		loggerContext: any,
		credentials: any,
		options: {
			errors: any;
		},
	) => null | Promise<any>;
	match: (
		context: SyncActionContext,
		externalUser: any,
		options: {
			errors: any;
			slug: string;
		},
	) => Promise<JellyfishTypes.core.Contract | null>;
	getExternalUserSyncEventData: (
		loggerContext: any,
		externalUser: any,
		options: {
			errors: any;
		},
	) => Promise<any>;

	new (params: IntegrationConstructorParams): Integration;
}
